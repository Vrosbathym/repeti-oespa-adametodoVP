<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sentio AI:: Intelig√™ncia textual que eleva seu aprendizado e sua capacidade de an√°lise</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        font-family: 'Inter', sans-serif;
      }
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
      @keyframes modal-scale-in {
          from { transform: scale(0.95); opacity: 0; }
          to { transform: scale(1); opacity: 1; }
        }
        .animate-modal-scale-in {
          animation: modal-scale-in 0.3s forwards cubic-bezier(0.165, 0.84, 0.44, 1);
        }
    </style>
    <script src="https://unpkg.com/@babel/standalone@7.24.0/babel.min.js"></script>
    <script type="importmap">
    {
      "imports": {
        "react/": "https://esm.sh/react@^19.1.0/",
        "react": "https://esm.sh/react@^19.1.0",
        "react-dom/": "https://esm.sh/react-dom@^19.1.0/",
        "@google/genai": "https://esm.sh/@google/genai@^1.3.0",
        "jspdf": "https://esm.sh/jspdf@^2.5.1",
        "pdfjs-dist/build/pdf.mjs": "https://esm.sh/pdfjs-dist@4.4.168/build/pdf.mjs"
      }
    }
    </script>
</head>
<body class="bg-gray-50 text-gray-800"> {/* Estilo Minimalista: Fundo Cinza Claro, Texto Escuro */}
    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript" data-type="module">
      import React, { useState, useCallback, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenAI } from "@google/genai";
      import jsPDF from 'jspdf';
      // Importando PDF.js e configurando o workerSrc com URL direto
      const { getDocument, GlobalWorkerOptions } = await import("pdfjs-dist/build/pdf.mjs");
      GlobalWorkerOptions.workerSrc = "https://esm.sh/pdfjs-dist@4.4.168/build/pdf.worker.mjs";

      // --- START OF ICON COMPONENTS ---
      // √çcones SVG como no seu arquivo original, mas KeyIcon ser√° usado no modal e no bot√£o de configurar API no header.
      // BrainCircuitIcon ser√° substitu√≠do pelo logo.png
      const BookOpenIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
        </svg>
      );
      const SparklesIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" {...props}>
          <path d="M12 .5l1.55 4.75h4.95l-3.8 3.45 1.55 4.75L12 10.5l-3.25 2.95 1.55-4.75-3.8-3.45h4.95L12 .5zm0 8l1.55 4.75h4.95l-3.8 3.45 1.55 4.75L12 18.5l-3.25 2.95 1.55-4.75-3.8-3.45h4.95L12 8.5zM4.5 17l1.55 4.75h4.95l-3.8 3.45L8.75 30l-3.25-2.95-3.25 2.95 1.55-4.75-3.8-3.45h4.95L4.5 17zm15 0l1.55 4.75h4.95l-3.8 3.45 1.55 4.75-3.25-2.95-3.25 2.95 1.55-4.75-3.8-3.45h4.95L19.5 17z" opacity="0.5" /><path d="M12 5l1 3h3.2l-2.6 2.3.9 3.2L12 11.3l-2.5 2.2.9-3.2L7.8 8H11l1-3z" />
        </svg>
      );
      const UploadIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>
        </svg>
      );
      const KeyIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path><circle cx="8.5" cy="15.5" r="2.5"></circle>
        </svg>
      );
      const DocumentTextIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line>
        </svg>
      );
      const ClipboardIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
        </svg>
      );
      const CheckCircleIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>
        </svg>
      );
      const DownloadIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
      );
      const ExclamationTriangleIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>
        </svg>
      );
      // --- END OF ICON COMPONENTS ---

      // --- START OF geminiAIService.ts LOGIC ---
      // Usando o nome do modelo do seu arquivo original
      const geminiModelName = "gemini-2.5-flash-preview-04-17";
      async function generateSummaryService(content) {
        if (!content || typeof content !== 'string' || !content.trim()) {
          throw new Error("O conte√∫do fornecido para an√°lise est√° vazio ou √© inv√°lido. Por favor, insira ou anexe um texto v√°lido.");
        }

        const userApiKey = localStorage.getItem('userGeminiApiKey');
        if (!userApiKey) {
          throw new Error("Nenhuma chave de API do Gemini foi configurada. Por favor, clique no √≠cone de chave üîë para adicionar sua chave.");
        }
        const ai = new GoogleGenAI({ apiKey: userApiKey }); // Sua inicializa√ß√£o original

        // Prompt do seu arquivo index (1).html, que j√° pede 10 quest√µes e tem instru√ß√µes sobre o gabarito
        const promptText = `
Voc√™ √© um assistente de IA especializado em criar materiais de estudo e apresenta√ß√£o com formata√ß√£o profissional.
Sua tarefa √© analisar o texto fornecido e gerar dois tipos de material:

PARTE 1: DOCUMENTO ESTRUTURADO
O documento DEVE SEGUIR ESTRITAMENTE A SEGUINTE ESTRUTURA para cada se√ß√£o principal identificada no texto:

## T√çTULO DA SE√á√ÉO/T√ìPICO PRINCIPAL
[Conte√∫do detalhado da se√ß√£o/t√≥pico, explicando os pontos principais, argumentos, evid√™ncias, etc. Mantenha uma linguagem formal e profissional. Separe par√°grafos com uma linha em branco.]

---

PARTE 2: QUEST√ïES PARA TESTAR O CONHECIMENTO
Com base no conte√∫do integral do texto fornecido na PARTE 1, gere EXATAMENTE 10 quest√µes (podem ser dissertativas, de m√∫ltipla escolha, ou uma combina√ß√£o) que permitam ao estudante testar seu conhecimento e compreens√£o do material. Se gerar quest√µes de m√∫ltipla escolha, indique a resposta correta entre par√™nteses, por exemplo: (Correta). Formate as quest√µes claramente.

### Perguntas de Revis√£o

[Liste as 10 quest√µes aqui.]

INSTRU√á√ïES IMPORTANTES GERAIS:
-   Para a PARTE 1, N√ÉO inclua nenhuma frase introdut√≥ria ou conclusiva sua antes do primeiro "## T√çTULO DA SE√á√ÉO". A PARTE 1 deve come√ßar diretamente com o primeiro t√≠tulo de se√ß√£o.
-   Use Markdown para toda a formata√ß√£o (t√≠tulos, listas, negrito).
-   A PARTE 2 (Perguntas de Revis√£o) deve vir AP√ìS todo o conte√∫do da PARTE 1 e ser claramente separada pela linha horizontal "---".
-   Se o texto fornecido pelo usu√°rio n√£o for leg√≠vel ou parecer ser dados brutos de um arquivo em vez de conte√∫do textual, responda com a seguinte mensagem e NADA MAIS: "O texto fornecido n√£o parece ser conte√∫do textual leg√≠vel para an√°lise. Por favor, forne√ßa um texto claro ou, se estiver carregando um arquivo, certifique-se de que √© um formato de texto simples (.txt, .md) ou que o conte√∫do de arquivos como PDF foi corretamente extra√≠do como texto."
-   O gabarito deve estar em uma pagina separada das quest√µes. 
-   Deve conter EXATAMENTE 10 quest√µes, e em caso de quest√µes objetivas, NAO FALAR QUAL A CORRETA NA QUEST√ÉO, APENAS NO GABARITO.

Texto para analisar e estruturar:
---
${content}
---
`;
        try {
          const response = await ai.models.generateContent({ model: geminiModelName, contents: promptText });
          let processedText = response.text;

          if (processedText === undefined || processedText === null) {
            throw new Error("A API n√£o retornou texto na resposta (response.text est√° vazio ou nulo).");
          }
          
          // Seu p√≥s-processamento original
          const specificPrefixPattern = /^Okay, aqui est√° o resumo detalhado baseado no texto fornecido,.*?elabora√ß√£o de respostas dissertativas:\s*\n?(?:\*\*(.*?)\*\*\s*?\n?)?/im;
          processedText = processedText.replace(specificPrefixPattern, "").trimStart();
          const commonIntros = ["Aqui est√° o resumo detalhado e estruturado:", "Claro, aqui est√° o resumo no formato solicitado:"];
          for (const intro of commonIntros) {
            if (processedText.toLowerCase().startsWith(intro.toLowerCase())) {
              processedText = processedText.substring(intro.length).trimStart();
              processedText = processedText.replace(/^\s*\*\*(.*?)\*\*\s*?\n?/, "").trimStart();
              break;
            }
          }
          
          // Ajuste sutil no p√≥s-processamento para o novo prompt: se n√£o come√ßar com ## E tiver ## E n√£o for j√° a se√ß√£o de perguntas
          if (!processedText.startsWith("## ") && processedText.includes("## ") && 
              (!processedText.includes("### Perguntas de Revis√£o") || processedText.indexOf("## ") < processedText.indexOf("### Perguntas de Revis√£o"))) {
            const lines = processedText.split('\n');
            let firstHeadingIndex = -1;
            for (let i = 0; i < lines.length; i++) {
              if (lines[i].startsWith("## ")) { firstHeadingIndex = i; break; }
            }
            if (firstHeadingIndex > 0) { // S√≥ remove o in√≠cio se houver algo antes do primeiro "##"
                processedText = lines.slice(firstHeadingIndex).join('\n');
            } else if (firstHeadingIndex === 0) {
                // J√° come√ßa com "##", n√£o faz nada
            }
          } else if (!processedText.startsWith("## ") && !processedText.includes("## ") && !processedText.includes("### Perguntas de Revis√£o")) {
            // Se n√£o encontrar nenhum ## e n√£o for a se√ß√£o de perguntas, pode ser um problema ou a IA n√£o seguiu o formato.
            console.warn("AI response does not start with '## ' and no '## ' found before questions. Outputting as received.");
          }


          if (processedText && processedText.trim()) { return processedText.trim(); }
          else { throw new Error("A API n√£o retornou nenhum conte√∫do de material de estudo √∫til ap√≥s o processamento."); }
        } catch (error) {
          console.error("Error calling Gemini API with user's key:", error);
          if (error instanceof Error) {
            if (error.message.includes("API key not valid") || error.message.includes("invalid api key")) {
              throw new Error("Sua chave de API do Gemini √© inv√°lida. Por favor, verifique-a e tente novamente.");
            }
            if (error.message.includes("quota")) {
              throw new Error("Sua cota da API Gemini foi excedida. Tente novamente mais tarde ou verifique sua conta Google AI Studio.");
            }
            if (error.message.includes("permission denied")) {
              throw new Error("Permiss√£o negada. Verifique se sua chave de API tem as permiss√µes necess√°rias para o modelo 'gemini-2.5-flash-preview-04-17'.");
            }
             if (error.message.includes("SAFETY") || (error.toString && error.toString().includes("SAFETY"))) {
                throw new Error("O conte√∫do n√£o p√¥de ser gerado devido √†s pol√≠ticas de seguran√ßa. Tente reformular o texto de entrada.");
            }
          }
          throw new Error(`Falha ao comunicar com a API do Gemini: ${error.message || 'Erro desconhecido'}`);
        }
      }
      // --- END OF geminiAIService.ts LOGIC ---

      // --- START OF UI COMPONENTS ---
      const LoadingIndicator = () => (
        <div className="flex flex-col items-center justify-center p-8 bg-white shadow-lg rounded-xl border border-gray-200">
          <svg className="animate-spin h-10 w-10 text-sky-500 mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
          <p className="text-gray-700 text-lg">Gerando material de estudo...</p><p className="text-gray-500 text-sm">Isso pode levar alguns instantes.</p>
        </div>
      );

      const ErrorMessageDisplay = ({ message }) => (
        <div className="bg-red-50 border border-red-300 text-red-700 px-4 py-3 rounded-lg relative shadow-md" role="alert">
          <div className="flex items-center"><ExclamationTriangleIcon className="h-6 w-6 text-red-500 mr-3" /><div><strong className="font-bold">Ocorreu um Erro!</strong><span className="block sm:inline ml-1">{message}</span></div></div>
        </div>
      );

      const ApiKeyModal = ({ isOpen, onClose, onApiKeyUpdated }) => {
        const [apiKeyInput, setApiKeyInput] = useState('');
        const [currentApiKeyMasked, setCurrentApiKeyMasked] = useState(null);
        const [saveStatus, setSaveStatus] = useState('idle');
        const [errorMessage, setErrorMessage] = useState(null);

        const maskApiKey = (key) => key.length <= 8 ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : `‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢${key.substring(key.length - 4)}`;
        const loadAndMaskKey = useCallback(() => {
          const storedKey = localStorage.getItem('userGeminiApiKey');
          if (storedKey) { setCurrentApiKeyMasked(maskApiKey(storedKey)); setApiKeyInput(''); } else { setCurrentApiKeyMasked(null); }
        }, []);

        useEffect(() => { if (isOpen) { loadAndMaskKey(); setSaveStatus('idle'); setErrorMessage(null); } }, [isOpen, loadAndMaskKey]);

        const handleSaveKey = () => {
          if (!apiKeyInput.trim()) { setErrorMessage('Por favor, insira uma chave de API v√°lida.'); setSaveStatus('error'); return; }
          try {
            localStorage.setItem('userGeminiApiKey', apiKeyInput.trim()); setSaveStatus('success'); setErrorMessage(null); onApiKeyUpdated(); loadAndMaskKey();
            setTimeout(() => { setSaveStatus('idle'); onClose(); }, 1500);
          } catch (error) { setErrorMessage('N√£o foi poss√≠vel salvar a chave. Verifique permiss√µes.'); setSaveStatus('error'); }
        };
        const handleClearKey = () => {
          try { localStorage.removeItem('userGeminiApiKey'); setApiKeyInput(''); setCurrentApiKeyMasked(null); setSaveStatus('idle'); setErrorMessage(null); onApiKeyUpdated(); }
          catch (error) { setErrorMessage('N√£o foi poss√≠vel limpar a chave.'); setSaveStatus('error'); }
        };

        if (!isOpen) return null;
        return (
          <div className="fixed inset-0 bg-gray-900/70 backdrop-blur-sm flex items-center justify-center p-4 z-50 transition-opacity duration-300 ease-out animate-modal-scale-in" onClick={onClose} role="dialog">
            <div className="bg-white p-6 sm:p-8 rounded-xl shadow-xl border border-gray-200 w-full max-w-md transform transition-all duration-300 ease-out" onClick={(e) => e.stopPropagation()}>
              <div className="flex items-center justify-between mb-6"><div className="flex items-center"><KeyIcon className="h-7 w-7 text-sky-500 mr-3" /><h2 className="text-2xl font-semibold text-gray-800">Configurar Chave de API</h2></div><button onClick={onClose} className="p-1 text-gray-500 hover:text-gray-700 rounded-full hover:bg-gray-100" aria-label="Fechar modal"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-7 h-7"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" /></svg></button></div>
              {currentApiKeyMasked && saveStatus !== 'success' && (<div className="mb-4 p-3 bg-gray-100 rounded-lg"><p className="text-sm text-gray-500">Chave de API atual:</p><p className="text-lg text-sky-600 font-mono tracking-wider">{currentApiKeyMasked}</p><button onClick={handleClearKey} className="mt-2 text-xs text-amber-600 hover:text-amber-700 hover:underline">Limpar Chave Salva</button></div>)}
              {saveStatus !== 'success' && (<div className="space-y-4"><p className="text-gray-600 text-sm">{currentApiKeyMasked ? "Para alterar, insira uma nova chave abaixo." : "Insira sua chave de API do Google Gemini para come√ßar a usar o aplicativo."}</p><div><label htmlFor="apiKeyInput" className="block text-sm font-medium text-gray-700 mb-1">Sua Chave de API Gemini</label><input type="password" id="apiKeyInput" value={apiKeyInput} onChange={(e) => { setApiKeyInput(e.target.value); if(saveStatus !== 'idle') setSaveStatus('idle'); if(errorMessage) setErrorMessage(null); }} placeholder="Cole sua chave aqui" className="w-full p-3 bg-gray-50 text-gray-800 border border-gray-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 placeholder-gray-400" /></div><button onClick={handleSaveKey} className="w-full flex items-center justify-center px-6 py-3 bg-sky-500 hover:bg-sky-600 text-white font-semibold rounded-lg shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500">Salvar Chave</button></div>)}
              {saveStatus === 'success' && (<div id="api-key-status" className="mt-4 p-4 bg-green-50 border border-green-300 rounded-lg text-center"><CheckCircleIcon className="h-8 w-8 text-green-500 mx-auto mb-2" /><p className="text-green-700 font-medium">Chave de API salva com sucesso!</p></div>)}
              {saveStatus === 'error' && errorMessage && (<div id="api-key-status" className="mt-4 p-4 bg-red-50 border border-red-300 rounded-lg text-center"><ExclamationTriangleIcon className="h-8 w-8 text-red-500 mx-auto mb-2" /><p className="text-red-700 font-medium">{errorMessage}</p></div>)}
              <p className="mt-6 text-xs text-gray-500 text-center">Sua chave de API √© armazenada apenas no seu navegador. Obtenha uma chave no <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="text-sky-600 hover:underline">Google AI Studio</a>.</p>
            </div>
          </div>
        );
      };

      const SummaryOutputArea = ({ summary }) => {
        const [copied, setCopied] = useState(false);
        const [isDownloadingPdf, setIsDownloadingPdf] = useState(false);
        const handleCopy = async () => { try { await navigator.clipboard.writeText(summary); setCopied(true); setTimeout(() => setCopied(false), 2000); } catch (err) { console.error("Failed to copy text: ", err); alert("Erro ao copiar texto. Tente manualmente."); } };
        
        const addPdfFooterInternal = (pdfInstance, pageHeight, pageWidth, marginValue) => {
            const originalFontSize = pdfInstance.getFontSize(); const originalFont = pdfInstance.getFont();
            pdfInstance.setFontSize(9); pdfInstance.setFont('helvetica', 'italic'); pdfInstance.setTextColor(150); // Cinza mais claro para rodap√©
            pdfInstance.text("Gerado por Sentio AI - Vinicius de Paiva Marti", pageWidth / 2, pageHeight - marginValue / 2, { align: 'center' });
            pdfInstance.setFontSize(originalFontSize); pdfInstance.setFont(originalFont.fontName, originalFont.fontStyle); pdfInstance.setTextColor(0); // Reset para preto
        };

        const handleDownloadPdf = async () => {
          if (!summary) return; setIsDownloadingPdf(true);
          try {
            const pdf = new jsPDF('p', 'pt', 'a4'); const pageHeight = pdf.internal.pageSize.getHeight(); const pageWidth = pdf.internal.pageSize.getWidth(); const margin = 40; const contentWidth = pageWidth - 2 * margin; const footerSpace = 30; let yPosition = margin;
            const baseFontSize = 11; const h1FontSize = 18; const h2FontSize = 14; const h3FontSize = 12; const lineHeightMultiplier = 1.45; const paragraphSpacing = baseFontSize * 0.7;
            
            const addFooterAndNewPageIfNeeded = (currentY, itemHeight = baseFontSize * lineHeightMultiplier) => { 
              if (currentY + itemHeight > pageHeight - margin - footerSpace) { 
                addPdfFooterInternal(pdf, pageHeight, pageWidth, margin); 
                pdf.addPage(); 
                return margin; 
              } 
              return currentY; 
            };
            
            const summaryLines = summary.split('\n');
            let isGabaritoSection = false;

            for (const line of summaryLines) {
              const trimmedLine = line.trimEnd(); 
              pdf.setFont('helvetica', 'normal'); pdf.setFontSize(baseFontSize); pdf.setTextColor(50, 50, 50); // Texto padr√£o cinza escuro

              if (trimmedLine.startsWith("## Gabarito") || trimmedLine.startsWith("### Gabarito")) { // Detec√ß√£o de in√≠cio do Gabarito
                isGabaritoSection = true;
                yPosition = addFooterAndNewPageIfNeeded(yPosition, h2FontSize * lineHeightMultiplier * 2); // Espa√ßo extra e poss√≠vel nova p√°gina
                pdf.addPage(); // For√ßa nova p√°gina para o gabarito
                yPosition = margin;
                
                const title = "Gabarito";
                pdf.setFontSize(h2FontSize); pdf.setFont('helvetica', 'bold'); pdf.setTextColor(0,0,0);
                const dims = pdf.getTextDimensions(title, {maxWidth: contentWidth, fontSize: h2FontSize});
                yPosition = addFooterAndNewPageIfNeeded(yPosition, dims.h * lineHeightMultiplier);
                pdf.text(title, margin, yPosition, {maxWidth: contentWidth});
                yPosition += dims.h * lineHeightMultiplier + paragraphSpacing;
                continue; // Pula o processamento normal da linha de t√≠tulo do gabarito
              }

              if (trimmedLine.startsWith("## ")) { 
                const title = trimmedLine.substring(3).trim(); 
                pdf.setFontSize(h1FontSize); pdf.setFont('helvetica', 'bold'); pdf.setTextColor(0,0,0);
                const dims = pdf.getTextDimensions(title, {maxWidth: contentWidth, fontSize: h1FontSize}); 
                yPosition = addFooterAndNewPageIfNeeded(yPosition, dims.h * lineHeightMultiplier); 
                pdf.text(title, margin, yPosition, {maxWidth: contentWidth}); 
                yPosition += dims.h * lineHeightMultiplier + paragraphSpacing; 
              } else if (trimmedLine.startsWith("### ")) { 
                const title = trimmedLine.substring(4).trim(); 
                pdf.setFontSize(h2FontSize); pdf.setFont('helvetica', 'bold'); pdf.setTextColor(20,20,20);
                const dims = pdf.getTextDimensions(title, {maxWidth: contentWidth, fontSize: h2FontSize}); 
                yPosition = addFooterAndNewPageIfNeeded(yPosition, dims.h * lineHeightMultiplier); 
                pdf.text(title, margin, yPosition, {maxWidth: contentWidth}); 
                yPosition += dims.h * lineHeightMultiplier + paragraphSpacing * 0.8; 
              } else if (trimmedLine.startsWith("---")) { 
                 yPosition = addFooterAndNewPageIfNeeded(yPosition, 15 + paragraphSpacing * 0.3);
                 pdf.setDrawColor(200, 200, 200); 
                 pdf.line(margin, yPosition, pageWidth - margin, yPosition);
                 yPosition += 15 + paragraphSpacing * 0.3;
              } else if (trimmedLine.startsWith("- ") || trimmedLine.startsWith("* ")) { 
                const leadingSpacesCount = (trimmedLine.match(/^(\s*)(-|\*)\s/) || ["", ""])[1].length; 
                let itemText = trimmedLine.substring(leadingSpacesCount + 2); 
                const indent = margin + 20 + (leadingSpacesCount * 12); 
                let isBold = false; 
                const boldMatch = itemText.match(/^\*\*(.*?)\*\*$/); 
                if (boldMatch && boldMatch[1]) { itemText = boldMatch[1]; isBold = true; }
                
                pdf.setFontSize(baseFontSize); pdf.setFont('helvetica', isBold ? 'bold' : 'normal'); 
                const bullet = "‚Ä¢"; 
                yPosition = addFooterAndNewPageIfNeeded(yPosition); 
                pdf.text(bullet, indent - 12, yPosition); // Ajuste do bullet
                
                const itemLines = pdf.splitTextToSize(itemText, contentWidth - (indent - margin) - pdf.getTextWidth(bullet + "  "));
                for (let i = 0; i < itemLines.length; i++) { 
                  if (i > 0) yPosition = addFooterAndNewPageIfNeeded(yPosition);
                  pdf.setFont('helvetica', isBold ? 'bold' : 'normal');
                  pdf.text(itemLines[i], indent, yPosition); 
                  yPosition += baseFontSize * lineHeightMultiplier;
                }
              } else if (trimmedLine.match(/^\s*\d+\.\s/)) { 
                const match = trimmedLine.match(/^(\s*)(\d+\.)\s(.*)/); 
                if (match) { 
                  const [, sp, num, txt] = match; 
                  const indent = margin + (sp.length * 10); 
                  pdf.setFontSize(baseFontSize); pdf.setFont('helvetica', 'normal'); 
                  yPosition = addFooterAndNewPageIfNeeded(yPosition); 
                  pdf.text(num, indent , yPosition); 
                  
                  const questionTextIndent = indent + pdf.getTextWidth(num + " ");
                  const itemLines = pdf.splitTextToSize(txt, contentWidth - (questionTextIndent - margin)); 
                  for(let i=0; i < itemLines.length; i++) { 
                    if (i > 0) yPosition = addFooterAndNewPageIfNeeded(yPosition);
                    pdf.text(itemLines[i], questionTextIndent, yPosition); 
                    yPosition += baseFontSize * lineHeightMultiplier;
                  }
                }
              } else if (trimmedLine) { 
                const textLines = pdf.splitTextToSize(trimmedLine, contentWidth); 
                for (const textLine of textLines) { 
                  yPosition = addFooterAndNewPageIfNeeded(yPosition); 
                  pdf.text(textLine, margin, yPosition); 
                  yPosition += baseFontSize * lineHeightMultiplier; 
                } 
                yPosition += paragraphSpacing * 0.5;
              } else { 
                yPosition = addFooterAndNewPageIfNeeded(yPosition, baseFontSize * 0.5); // Smaller space for empty line
                yPosition += baseFontSize * 0.5 * lineHeightMultiplier; 
              }
            }
            addPdfFooterInternal(pdf, pageHeight, pageWidth, margin); 
            pdf.save('SentioAI_Material_Estudo.pdf');
          } catch (e) { console.error("PDF gen error:", e); alert("Erro ao gerar PDF."); } finally { setIsDownloadingPdf(false); }
        };
        return (
          <div className="bg-white shadow-lg rounded-xl p-6 sm:p-8 border border-gray-200">
            <div className="flex flex-col sm:flex-row items-center justify-between mb-6 gap-3 sm:gap-0">
              <div className="flex items-center"><DocumentTextIcon className="h-7 w-7 text-sky-500 mr-3" />
                <h2 className="text-2xl font-semibold text-gray-800">Material Gerado</h2>
              </div>
              <div className="flex items-center gap-3">
                <button onClick={handleDownloadPdf} disabled={isDownloadingPdf || !summary} className="flex items-center px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 border border-gray-300 text-sm font-medium rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 transition-colors duration-200 disabled:opacity-60 disabled:cursor-not-allowed">
                  {isDownloadingPdf ? (<><svg className="animate-spin -ml-1 mr-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Gerando...</>) : (<><DownloadIcon className="h-5 w-5 mr-2" />Baixar PDF</>)}
                </button>
                <button onClick={handleCopy} disabled={isDownloadingPdf} className="flex items-center px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 border border-gray-300 text-sm font-medium rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 transition-colors duration-200 disabled:opacity-60">
                  {copied ? (<><CheckCircleIcon className="h-5 w-5 mr-2 text-green-500" />Copiado!</>) : (<><ClipboardIcon className="h-5 w-5 mr-2" />Copiar</>)}
                </button>
              </div>
            </div>
            <div className="prose prose-sm sm:prose-base prose-gray max-w-none p-4 bg-gray-50 rounded-lg whitespace-pre-wrap text-gray-700 overflow-x-auto">{summary}</div>
          </div>
        );
      };

      const ContentInputArea = ({ inputText, onInputChange, onSummarize, isLoading, isApiKeySet, onConfigureApiKeyClick }) => {
        const [fileName, setFileName] = useState(null);
        const [fileError, setFileError] = useState(null);
        const fileInputRef = useRef(null);
        const acceptedFileTypes = ".txt,.md,.rtf,.html,.xml,.json,.csv,.tsv,.js,.ts,.py,.java,.c,.cpp,.cs,.php,.rb,.swift,.kt,.go,.rs,.pl,.sh,.css,.scss,.less,.pdf";
        
        const handleFileChange = async (event) => {
          const files = event.target.files; if (!files || files.length === 0) { setFileError(null); return; }
          
          setFileError(null);
          let combinedText = "";
          const successfullyLoadedFileNames = [];
          let anyFileFailed = false;
          let unsupportedFiles = [];

          const fileProcessingPromises = Array.from(files).map(file => {
            return new Promise(async (resolve) => {
              try {
                if (file.type === "application/pdf") {
                  const reader = new FileReader();
                  reader.onload = async (e_pdf) => {
                    try {
                      const typedArray = new Uint8Array(e_pdf.target.result);
                      const pdfDoc = await getDocument(typedArray).promise;
                      let pdfText = "";
                      for (let i = 1; i <= pdfDoc.numPages; i++) {
                        const page = await pdfDoc.getPage(i);
                        const textContent = await page.getTextContent();
                        pdfText += textContent.items.map(item => item.str).join(" ") + "\n";
                      }
                      resolve({ name: file.name, text: pdfText.trim(), status: 'fulfilled' });
                    } catch (pdfError) {
                      console.error(`Erro ao processar PDF ${file.name}:`, pdfError);
                      resolve({ name: file.name, text: "", status: 'rejected', reason: `Falha ao extrair texto do PDF: ${file.name}.` });
                    }
                  };
                  reader.onerror = () => {
                    resolve({ name: file.name, text: "", status: 'rejected', reason: `Erro ao ler o arquivo PDF: ${file.name}` });
                  }
                  reader.readAsArrayBuffer(file);
                } else if (acceptedFileTypes.split(',').some(type => file.name.endsWith(type.trim()) || (file.type && file.type.startsWith(type.trim().replace('.', '')) && type.trim() !== '.pdf' ) )) {
                  const reader = new FileReader();
                  reader.onload = (e_text) => {
                     resolve({ name: file.name, text: e_text.target.result || "", status: 'fulfilled' });
                  }
                  reader.onerror = () => {
                     resolve({ name: file.name, text: "", status: 'rejected', reason: `Erro ao ler o arquivo: ${file.name}` });
                  }
                  reader.readAsText(file);
                } else {
                  unsupportedFiles.push(file.name);
                  resolve({ name: file.name, text: "", status: 'fulfilled', unsupported: true });
                }
              } catch (generalError) {
                 console.error(`Erro geral ao processar arquivo ${file.name}:`, generalError);
                 resolve({ name: file.name, text: "", status: 'rejected', reason: `Erro inesperado ao processar ${file.name}`});
              }
            });
          });

          const results = await Promise.all(fileProcessingPromises);
          
          results.forEach(result => {
            if (result.status === 'fulfilled' && !result.unsupported && result.text && result.text.trim()) {
              combinedText += (combinedText ? "\n\n---\n\n" : "") + result.text.trim();
              successfullyLoadedFileNames.push(result.name);
            } else if (result.status === 'rejected') {
              anyFileFailed = true;
              console.error("Falha ao processar o arquivo:", result.name, result.reason);
            }
          });
          
          let currentFileError = null;
          if (unsupportedFiles.length > 0) {
            currentFileError = `Arquivos n√£o suportados para extra√ß√£o autom√°tica de texto: ${unsupportedFiles.join(', ')}. Para estes, tente copiar e colar o conte√∫do.`;
            if (anyFileFailed && successfullyLoadedFileNames.length > 0) {
                currentFileError += " Outros arquivos podem ter falhado ou sido lidos com sucesso.";
            } else if (anyFileFailed) {
                 currentFileError += " Alguns arquivos tamb√©m falharam ao serem processados.";
            }
          } else if (anyFileFailed) {
            currentFileError = "Alguns arquivos n√£o puderam ser lidos ou processados. O conte√∫do dos arquivos lidos com sucesso foi carregado, se houver.";
          }
          setFileError(currentFileError);
          
          onInputChange(combinedText.trim()); 
          setFileName(successfullyLoadedFileNames.length > 0 ? successfullyLoadedFileNames.join(', ') : null);
          if (fileInputRef.current) fileInputRef.current.value = ""; 
        };

        const handleTextareaChange = (e) => { onInputChange(e.target.value); if (fileName) setFileName(null); if (fileError) setFileError(null); };

        return (
          <div className="bg-white shadow-lg rounded-xl p-6 sm:p-8 border border-gray-200">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6">
              <div className="flex items-center mb-3 sm:mb-0">
                <BookOpenIcon className="h-7 w-7 text-sky-500 mr-3" />
                <h2 className="text-2xl font-semibold text-gray-800">Insira seu Conte√∫do</h2>
              </div>
              <div className="flex flex-col items-start sm:items-end">
                <input type="file" id="file-upload" ref={fileInputRef} className="hidden" accept={acceptedFileTypes} onChange={handleFileChange} disabled={isLoading} multiple />
                <label htmlFor="file-upload" className={`flex items-center justify-center px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 border border-gray-300 font-medium rounded-lg shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-sky-500 transition-all duration-200 cursor-pointer ${isLoading ? 'opacity-50 cursor-not-allowed' : ''}`} role="button" tabIndex={isLoading ? -1 : 0} onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') fileInputRef.current?.click();}}>
                  <UploadIcon className="h-5 w-5 mr-2" />Anexar Arquivo(s)
                </label>
                {fileName && (<p className="text-xs text-sky-600 mt-1 truncate max-w-xs sm:max-w-sm md:max-w-md" title={fileName}>{`Carregado${fileName.includes(',')?'s':''}: ${fileName}`}</p>)}
              </div>
            </div>
            {fileError && (<p className="text-sm text-red-600 mb-3" role="alert">{fileError}</p>)}
            <p className="text-gray-600 mb-4 text-sm">
              Cole seu texto abaixo, escreva diretamente ou anexe arquivos (.txt, .md, .pdf, etc.). A IA ir√° process√°-lo para criar um material de estudo com resumo, e quest√µes.
            </p>
            <textarea value={inputText} onChange={handleTextareaChange} placeholder="Digite, cole o conte√∫do ou anexe arquivo(s) acima..." className="w-full h-64 p-4 bg-gray-50 text-gray-800 border border-gray-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition-shadow duration-200 resize-y placeholder-gray-400" disabled={isLoading} aria-label="√Årea de entrada de conte√∫do"></textarea>
            <div className="flex flex-col sm:flex-row justify-between items-center mt-6 gap-4">
              <div className="text-sm text-gray-500">
                <p>{inputText.length} caracteres</p>
                {!isApiKeySet && (
                  <button onClick={onConfigureApiKeyClick} className="text-amber-600 hover:text-amber-700 text-xs mt-1 flex items-center underline focus:outline-none focus:ring-1 focus:ring-amber-500 rounded">
                    <KeyIcon className="h-4 w-4 mr-1 inline-block" />Chave de API n√£o configurada. <span className="font-semibold ml-1">Clique aqui para configurar.</span>
                  </button>
                )}
              </div>
              <button onClick={onSummarize} disabled={isLoading || !inputText.trim() || !isApiKeySet} className="flex items-center justify-center px-6 py-3 bg-sky-500 hover:bg-sky-600 text-white font-semibold rounded-lg shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed w-full sm:w-auto" aria-live="polite">
                {isLoading ? (<><svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Processando...</>) : (<><SparklesIcon className="h-5 w-5 mr-2" />Gerar Material de Estudo</>)}
              </button>
            </div>
          </div>
        );
      };
      // --- END OF UI COMPONENTS ---

      // --- START OF App.tsx LOGIC ---
      const App = () => {
        const [inputText, setInputText] = useState('');
        const [summary, setSummary] = useState('');
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState(null);
        const [userApiKeyExists, setUserApiKeyExists] = useState(false);
        const [isApiKeyModalOpen, setIsApiKeyModalOpen] = useState(false);

        useEffect(() => { const storedApiKey = localStorage.getItem('userGeminiApiKey'); setUserApiKeyExists(!!storedApiKey); }, []);
        const handleSummarize = useCallback(async () => {
          if (!userApiKeyExists) { setError('Por favor, configure sua chave de API do Gemini para gerar o material.'); setIsApiKeyModalOpen(true); return; }
          if (!inputText.trim()) { setError('Por favor, insira algum conte√∫do para gerar o material de estudo.'); return; }
          setIsLoading(true); setError(null); setSummary('');
          try { const result = await generateSummaryService(inputText); setSummary(result); }
          catch (err) { 
            if (err instanceof Error) { setError(err.message || 'Ocorreu um erro ao gerar o material de estudo.'); } 
            else { setError('Ocorreu um erro desconhecido.'); }
            console.error("Error generating material:", err); 
          }
          finally { setIsLoading(false); }
        }, [inputText, userApiKeyExists]);
        const handleApiKeyUpdated = () => { const storedApiKey = localStorage.getItem('userGeminiApiKey'); setUserApiKeyExists(!!storedApiKey); if(error && error.includes("chave de API")) { setError(null); }};
        const toggleApiKeyModal = () => setIsApiKeyModalOpen(!isApiKeyModalOpen);

        return (
          <div className="min-h-screen flex flex-col items-center p-4 sm:p-8 selection:bg-sky-300 selection:text-sky-900"> {/* bg-gray-50 text-gray-800 j√° est√° no body */}
            <header className="w-full max-w-4xl mb-10 text-center">
              <div className="flex items-center justify-center mb-3 relative">
                {/* Substitu√≠do BrainCircuitIcon por logo.png */}
                <img src="logo.png" alt="Sentio AI Logo" className="h-10 w-auto mr-3" /> {/* Ajuste h-10 w-auto para manter propor√ß√£o */}
                <h1 className="text-4xl sm:text-5xl font-bold text-gray-800">Sentio AI</h1>
                <button 
                  onClick={toggleApiKeyModal} 
                  className="absolute right-0 top-1/2 -translate-y-1/2 p-2 text-gray-500 hover:text-sky-600 transition-colors" 
                  title="Configurar Chave de API Gemini"
                  aria-label="Configurar Chave de API Gemini"
                >
                  <KeyIcon className="h-6 w-6" />
                </button>
              </div>
              <p className="text-lg text-gray-600">Intelig√™ncia textual que eleva seu aprendizado e sua capacidade de an√°lise.</p>
            </header>
            <main className="w-full max-w-4xl space-y-8">
              <ContentInputArea inputText={inputText} onInputChange={setInputText} onSummarize={handleSummarize} isLoading={isLoading} isApiKeySet={userApiKeyExists} onConfigureApiKeyClick={toggleApiKeyModal} />
              {isLoading && <LoadingIndicator />}
              {error && <ErrorMessageDisplay message={error} />}
              {summary && !isLoading && <SummaryOutputArea summary={summary} />}
            </main>
            <footer className="w-full max-w-4xl mt-16 text-center text-gray-500 text-sm">
                <p>&copy; {new Date().getFullYear()} Sentio AI. Todos os direitos reservados.</p>
                <p className="mt-1">Desenvolvido por Vinicius de Paiva Marti.</p>
            </footer>
            <ApiKeyModal isOpen={isApiKeyModalOpen} onClose={toggleApiKeyModal} onApiKeyUpdated={handleApiKeyUpdated} />
          </div>
        );
      };
      // --- END OF App.tsx LOGIC ---

      // --- Mount the App ---
      const rootElement = document.getElementById('root');
      if (!rootElement) { throw new Error("Root element not found"); }
      const root = ReactDOM.createRoot(rootElement);
      root.render(<App />);
    </script>
</body>
</html>
